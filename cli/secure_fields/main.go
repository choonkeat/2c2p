package main

import (
	"crypto/hmac"
	"crypto/sha1"
	"encoding/base64"
	"encoding/hex"
	"encoding/xml"
	"flag"
	"fmt"
	"html/template"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	api2c2p "github.com/choonkeat/2c2p"
)

var (
	// Server configuration
	port      = flag.Int("port", 8080, "Port to run the server on")
	serverURL = flag.String("serverURL", "http://localhost:8080", "Your server URL prefix (e.g., https://your-domain.com)")

	// 2C2P configuration
	sandbox        = flag.Bool("sandbox", true, "Use sandbox environment")
	merchantID     = flag.String("merchantID", "", "2C2P Merchant ID")
	secretKey      = flag.String("secretKey", "", "2C2P Secret Key")
	c2cpURL        = flag.String("c2cpURL", "https://demo2.2c2p.com", "2C2P server URL")
	privateKeyFile = flag.String("privateKey", "dist/combined_private_public.pem", "Path to combined private key and certificate PEM file generated by cli/server-to-server-key/main.go")

	// Form configuration
	formAction = flag.String("formAction", "/process-payment", "Form action URL")
)

// main starts a web server that demonstrates the 2C2P payment flow:
// 1. Displays a payment form with secure card fields
// 2. Processes the payment request and redirects to 2C2P
// 3. Handles the payment response and displays the result
// 4. Receives backend notifications for payment status updates
func main() {
	flag.Parse()

	// Verify private key file exists and can be read
	privateKey, err := os.ReadFile(*privateKeyFile)
	if err != nil {
		log.Fatalf("Error reading private key file %q: %v", *privateKeyFile, err)
	}

	// Generate the payment form HTML with secure fields
	secureFieldsHTML := api2c2p.GenerateSecureFieldsHTML(*formAction, *sandbox)

	// Handler for the payment form page
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		log.Println(r.Method, r.URL.String())
		tmpl, err := template.New("securefields").Parse(secureFieldsHTML)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "text/html")
		if err := tmpl.Execute(w, nil); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
	})

	// Handler for processing payment form submission
	http.HandleFunc("/process-payment", handlePaymentRequest)

	// Handler for payment response from 2C2P
	// Create a closure to pass the pre-loaded private key
	http.HandleFunc("/payment-return", func(w http.ResponseWriter, r *http.Request) {
		handlePaymentResponse(w, r, privateKey)
	})

	// Handler for backend payment notifications
	http.HandleFunc("/payment-notify", handlePaymentNotification)

	// Start the server
	addr := fmt.Sprintf(":%d", *port)
	log.Printf("Starting server at http://localhost%s\n", addr)
	if err := http.ListenAndServe(addr, nil); err != nil {
		log.Fatal(err)
	}
}

// handlePaymentRequest processes the payment form submission:
// 1. Validates the request
// 2. Creates a payment request XML
// 3. Signs the request with HMAC
// 4. Redirects to 2C2P payment page
func handlePaymentRequest(w http.ResponseWriter, r *http.Request) {
	log.Println(r.Method, r.URL.String())
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	if err := r.ParseForm(); err != nil {
		http.Error(w, "Error parsing form: "+err.Error(), http.StatusBadRequest)
		return
	}

	// Get encrypted card data from secure fields
	encryptedCardInfo := r.PostFormValue("encryptedCardInfo")

	// Prepare payment request parameters
	timestamp := fmt.Sprintf("%d", time.Now().Unix())
	invoiceNo := fmt.Sprintf("INV%s", timestamp)
	paymentDetails := struct {
		Amount       string // 12 digits
		CurrencyCode string // ISO 4217
		Description  string
		CustomerName string
		CountryCode  string // ISO 3166
		StoreCard    string // Y/N
		UserDefined1 string
		UserDefined2 string
		UserDefined3 string
		UserDefined4 string
		UserDefined5 string
	}{
		Amount:       "000000009910", // $100.10
		CurrencyCode: "702",          // SGD
		Description:  "1 room for 2 nights",
		CustomerName: "John Doe",
		CountryCode:  "SG",
		StoreCard:    "Y",
		UserDefined1: "1",
		UserDefined2: "2",
		UserDefined3: "3",
		UserDefined4: "4",
		UserDefined5: "5",
	}

	// Create HMAC signature string
	strToHash := createSignatureString(
		"9.4", // API version
		timestamp,
		*merchantID,
		invoiceNo,
		paymentDetails,
		encryptedCardInfo,
	)
	hmacHash := createHMAC(strToHash, *secretKey)

	// Create payment request XML
	xmlStr := fmt.Sprintf(`<PaymentRequest>
		<version>9.4</version>
		<timeStamp>%s</timeStamp>
		<merchantID>%s</merchantID>
		<uniqueTransactionCode>%s</uniqueTransactionCode>
		<desc>%s</desc>
		<amt>%s</amt>
		<currencyCode>%s</currencyCode>
		<paymentChannel></paymentChannel>
		<panCountry>%s</panCountry>
		<cardholderName>%s</cardholderName>
		<request3DS>Y</request3DS>
		<secureHash>%s</secureHash>
		<storeCard>%s</storeCard>
		<encCardData>%s</encCardData>
		<userDefined1>%s</userDefined1>
		<userDefined2>%s</userDefined2>
		<userDefined3>%s</userDefined3>
		<userDefined4>%s</userDefined4>
		<userDefined5>%s</userDefined5>
	</PaymentRequest>`,
		timestamp,
		*merchantID,
		invoiceNo,
		paymentDetails.Description,
		paymentDetails.Amount,
		paymentDetails.CurrencyCode,
		paymentDetails.CountryCode,
		paymentDetails.CustomerName,
		hmacHash,
		paymentDetails.StoreCard,
		encryptedCardInfo,
		paymentDetails.UserDefined1,
		paymentDetails.UserDefined2,
		paymentDetails.UserDefined3,
		paymentDetails.UserDefined4,
		paymentDetails.UserDefined5,
	)

	// Base64 encode the XML
	payload := base64.StdEncoding.EncodeToString([]byte(xmlStr))

	// Render auto-submitting form to 2C2P
	renderRedirectForm(w, *c2cpURL, payload)
}

// handlePaymentResponse processes the payment response from 2C2P:
// 1. Decrypts the response using our private key
// 2. Parses the payment result XML
// 3. Displays the payment result to the customer
func handlePaymentResponse(w http.ResponseWriter, r *http.Request, privateKey []byte) {
	log.Println(r.Method, r.URL.String())
	if err := r.ParseForm(); err != nil {
		http.Error(w, "Error parsing form: "+err.Error(), http.StatusBadRequest)
		return
	}

	// Get encrypted payment response
	encryptedResponse := r.FormValue("paymentResponse")
	log.Printf("Received payment response: %s\n", encryptedResponse)

	// Decrypt the response
	decrypted, err := api2c2p.DecryptPKCS7([]byte(encryptedResponse), privateKey)
	if err != nil {
		http.Error(w, "Error decrypting response: "+err.Error(), http.StatusInternalServerError)
		return
	}
	log.Printf("Decrypted response: %s\n", string(decrypted))

	// Parse the XML response
	var response api2c2p.PaymentResponseBackEnd
	if err := xml.Unmarshal(decrypted, &response); err != nil {
		http.Error(w, "Error parsing XML response: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Display payment result to customer
	renderPaymentResult(w, response, string(decrypted))
}

// handlePaymentNotification processes backend notifications from 2C2P
// These notifications are used to update the payment status in your system
func handlePaymentNotification(w http.ResponseWriter, r *http.Request) {
	log.Println(r.Method, r.URL.String())
	if err := r.ParseForm(); err != nil {
		http.Error(w, "Error parsing form: "+err.Error(), http.StatusBadRequest)
		return
	}
	log.Printf("Payment notification received: %v", r.PostForm)
	w.WriteHeader(http.StatusOK)
}

// Helper functions

func createSignatureString(apiVersion, timestamp, merchantID, invoiceNo string, details struct {
	Amount       string
	CurrencyCode string
	Description  string
	CustomerName string
	CountryCode  string
	StoreCard    string
	UserDefined1 string
	UserDefined2 string
	UserDefined3 string
	UserDefined4 string
	UserDefined5 string
}, encryptedCardInfo string) string {
	// Construct signature string with all fields in the same order as PHP
	return fmt.Sprintf("%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
		apiVersion,           // version
		timestamp,            // timestamp
		merchantID,           // merchantID
		invoiceNo,            // uniqueTransactionCode
		details.Description,  // desc
		details.Amount,       // amt
		details.CurrencyCode, // currencyCode
		"",                   // paymentChannel
		"",                   // storeCardUniqueID
		"",                   // panBank
		details.CountryCode,  // country
		details.CustomerName, // cardholderName
		"",                   // cardholderEmail
		"",                   // payCategoryID
		details.UserDefined1, // userDefined1
		details.UserDefined2, // userDefined2
		details.UserDefined3, // userDefined3
		details.UserDefined4, // userDefined4
		details.UserDefined5, // userDefined5
		details.StoreCard,    // storeCard
		"",                   // ippTransaction
		"",                   // installmentPeriod
		"",                   // interestType
		"",                   // recurring
		"",                   // invoicePrefix
		"",                   // recurringAmount
		"",                   // allowAccumulate
		"",                   // maxAccumulateAmt
		"",                   // recurringInterval
		"",                   // recurringCount
		"",                   // chargeNextDate
		"",                   // promotion
		"Y",                  // request3DS
		"",                   // statementDescriptor
		"",                   // agentCode
		"",                   // channelCode
		"",                   // paymentExpiry
		"",                   // mobileNo
		"",                   // tokenizeWithoutAuthorization
		encryptedCardInfo,    // encryptedCardInfo
	)
}

func createHMAC(data, key string) string {
	h := hmac.New(sha1.New, []byte(key))
	h.Write([]byte(data))
	return strings.ToUpper(hex.EncodeToString(h.Sum(nil)))
}

func renderRedirectForm(w http.ResponseWriter, c2cpURL, payload string) {
	w.Header().Set("Content-Type", "text/html")
	fmt.Fprintf(w, `<!DOCTYPE html>
<html>
<body>
	<form action="%s/2C2PFrontEnd/SecurePayment/PaymentAuth.aspx" method="POST" name="paymentRequestForm">
		<p>Processing payment request. Please do not close the browser, press back or refresh the page.</p>
		<input type="hidden" name="paymentRequest" value="%s">
	</form>
	<script>document.paymentRequestForm.submit();</script>
</body>
</html>`, c2cpURL, payload)
}

func renderPaymentResult(w http.ResponseWriter, response api2c2p.PaymentResponseBackEnd, rawResponse string) {
	w.Header().Set("Content-Type", "text/html")

	type templateData struct {
		StatusClass string
		StatusText  string
		FailReason  template.HTML
		TransCode   string
		Amount      string
		CardNumber  string
		CardType    string
		Bank        string
		RespCode    string
		DateTime    string
		RawResponse string
	}

	isSuccess := response.Status == "A" && response.RespCode == "00"

	statusClass := "failure"
	if isSuccess {
		statusClass = "success"
	}

	statusText := "Failed"
	if isSuccess {
		statusText = "Success"
	}

	var failReasonHTML template.HTML
	if response.FailReason != "" {
		failReasonHTML = template.HTML(fmt.Sprintf(`<p class="failure">Reason: %s</p>`, template.HTMLEscapeString(response.FailReason)))
	}

	tmpl := template.Must(template.New("result").Parse(`<!DOCTYPE html>
<html>
<head>
	<style>
		.payment-details { margin: 20px; }
		.payment-details dt { font-weight: bold; margin-top: 10px; }
		.success { color: green; }
		.failure { color: red; }
	</style>
</head>
<body>
	<h1>Payment Result</h1>
	<div class="payment-details">
		<h2>Payment Status: <span class="{{.StatusClass}}">{{.StatusText}}</span></h2>
		{{.FailReason}}
		<dl>
			<dt>Transaction Code:</dt><dd>{{.TransCode}}</dd>
			<dt>Amount:</dt><dd>{{.Amount}}</dd>
			<dt>Card:</dt><dd>{{.CardNumber}} ({{.CardType}})</dd>
			<dt>Bank:</dt><dd>{{.Bank}}</dd>
			<dt>Response Code:</dt><dd>{{.RespCode}}</dd>
			<dt>DateTime:</dt><dd>{{.DateTime}}</dd>
		</dl>
	</div>
	<h3>Raw Response</h3>
	<pre>{{.RawResponse}}</pre>
</body>
</html>`))

	data := templateData{
		StatusClass: statusClass,
		StatusText:  statusText,
		FailReason:  failReasonHTML,
		TransCode:   response.UniqueTransactionCode,
		Amount:      response.Amount,
		CardNumber:  response.PAN,
		CardType:    response.CardType,
		Bank:        response.BankName,
		RespCode:    response.RespCode,
		DateTime:    response.DateTime,
		RawResponse: rawResponse,
	}

	if err := tmpl.Execute(w, data); err != nil {
		http.Error(w, "Error rendering template: "+err.Error(), http.StatusInternalServerError)
		return
	}
}
