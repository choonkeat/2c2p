package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"html/template"
	"log"
	"net/http"
	"os"
	"strconv"
	"time"

	api2c2p "github.com/choonkeat/2c2p"
)

var (
	// Server configuration
	port      = flag.Int("port", 8080, "Port to run the server on")
	serverURL = flag.String("serverURL", "http://localhost:8080", "Your server URL prefix (e.g., https://your-domain.com)")

	// 2C2P configuration
	merchantID     = flag.String("merchantID", "", "2C2P Merchant ID")
	secretKey      = flag.String("secretKey", "", "2C2P Secret Key")
	c2cpURL        = flag.String("c2cpURL", "https://demo2.2c2p.com", "2C2P server URL")
	privateKeyFile = flag.String("privateKey", "dist/combined_private_public.pem", "Path to combined private key and certificate PEM file generated by cli/server-to-server-key/main.go")
)

const qrPaymentHTML = `
<!DOCTYPE html>
<html>
<head>
    <title>QR Payment</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .qr-container {
            text-align: center;
            margin: 20px 0;
        }
        .qr-image {
            max-width: 300px;
            margin: 20px auto;
        }
        .status {
            text-align: center;
            margin: 20px 0;
            padding: 10px;
            border-radius: 4px;
        }
        .pending {
            background-color: #fff3cd;
            color: #856404;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <h1>QR Payment</h1>
    <form id="paymentForm" action="/process-payment" method="POST">
        <div>
            <label for="amount">Amount:</label>
            <input type="number" id="amount" name="amount" step="0.01" required>
        </div>
        <div>
            <label for="currency">Currency:</label>
            <select id="currency" name="currency" required>
                <option value="SGD">SGD</option>
                <option value="THB">THB</option>
                <option value="MYR">MYR</option>
            </select>
        </div>
        <div>
            <label for="description">Description:</label>
            <input type="text" id="description" name="description" required>
        </div>
        <div>
            <button type="submit">Generate QR Code</button>
        </div>
    </form>
    <div id="qrContainer" class="qr-container" style="display: none;">
        <img id="qrImage" class="qr-image" src="" alt="QR Code">
        <div id="status" class="status pending">
            Waiting for payment...
        </div>
    </div>
    <script>
        document.getElementById('paymentForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            const formData = {
                amount: document.getElementById('amount').value,
                currency: document.getElementById('currency').value,
                description: document.getElementById('description').value
            };

            try {
                // Step 1: Process payment and get QR code
                const response = await fetch('/process-payment', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
                });
                const data = await response.json();

                if (data.data) {
                    // Show QR code
                    document.getElementById('qrContainer').style.display = 'block';
                    document.getElementById('qrImage').src = data.data;

                    // Start polling for payment status
                    pollPaymentStatus(data.paymentToken);
                } else {
                    alert('Error generating QR code: ' + data.error);
                }
            } catch (error) {
                alert('Error processing payment: ' + error);
            }
        });

        async function pollPaymentStatus(paymentToken) {
            const statusElement = document.getElementById('status');

            while (true) {
                try {
                    const response = await fetch('/payment-status?token=' + encodeURIComponent(paymentToken));
                    const data = await response.json();

                    statusElement.textContent = data.message;
                    statusElement.className = 'status ' + data.status;

                    if (data.status === 'success' || data.status === 'error') {
                        break;
                    }

                    await new Promise(resolve => setTimeout(resolve, 3000));
                } catch (error) {
                    console.error('Error checking payment status:', error);
                    await new Promise(resolve => setTimeout(resolve, 3000));
                }
            }
        }
    </script>
</body>
</html>
`

func main() {
	flag.Parse()

	if *merchantID == "" || *secretKey == "" {
		log.Fatal("merchantID and secretKey are required")
	}

	// Verify private key file exists and can be read
	if _, err := os.ReadFile(*privateKeyFile); err != nil {
		log.Fatalf("Error reading private key file %q: %v", *privateKeyFile, err)
	}

	// Create 2C2P client
	client := api2c2p.NewClient(api2c2p.Config{
		SecretKey:  *secretKey,
		MerchantID: *merchantID,
		BaseURL:    *c2cpURL,
	})

	// Handler for the payment form page
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		log.Printf("%s %s", r.Method, r.URL.String())
		tmpl, err := template.New("qrpayment").Parse(qrPaymentHTML)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "text/html")
		if err := tmpl.Execute(w, nil); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		}
	})

	// Handler for processing payment and generating QR code
	http.HandleFunc("/process-payment", handleQRPayment(client))

	// Handler for checking payment status
	http.HandleFunc("/payment-status", func(w http.ResponseWriter, r *http.Request) {
		log.Printf("%s %s", r.Method, r.URL.String())
		token := r.URL.Query().Get("token")
		if token == "" {
			http.Error(w, "Payment token is required", http.StatusBadRequest)
			return
		}

		// Query payment status
		status, err := client.PaymentInquiryByToken(r.Context(), &api2c2p.PaymentInquiryByTokenRequest{
			PaymentToken: token,
			Locale:       "en",
		})
		log.Printf("Payment status: %#v, %s", status, err)
		if err != nil {
			json.NewEncoder(w).Encode(map[string]string{
				"status":  "error",
				"message": "Error checking payment status: " + err.Error(),
			})
			return
		}
		log.Printf("Payment status: %#v", status)

		var response struct {
			Status  string `json:"status"`
			Message string `json:"message"`
		}

		switch status.RespCode {
		case "0000":
			response.Status = "success"
			response.Message = "Payment successful!"
		case "1005":
		case "2001":
			response.Status = "pending"
			response.Message = "Waiting for payment..."
		default:
			response.Status = "error"
			response.Message = fmt.Sprintf("Payment failed: %s (%s)", status.RespDesc, status.RespCode)
		}

		json.NewEncoder(w).Encode(response)
	})

	// Handler for payment notifications
	http.HandleFunc("/payment-notify", func(w http.ResponseWriter, r *http.Request) {
		log.Printf("%s %s", r.Method, r.URL.String())
		// Handle backend payment notification
		// This should update your database with the payment status
		log.Printf("Received payment notification: %+v", r.PostForm)
		w.WriteHeader(http.StatusOK)
	})

	// Handler for QR payment callback
	http.HandleFunc("/qr-payment-callback", handleQRPaymentCallback)

	// Start the server
	addr := fmt.Sprintf(":%d", *port)
	log.Printf("Starting QR Payment server at http://localhost%s\n", addr)
	if err := http.ListenAndServe(addr, nil); err != nil {
		log.Fatal(err)
	}
}

func handleQRPayment(client *api2c2p.Client) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		log.Printf("%s %s", r.Method, r.URL.String())
		if r.Method != http.MethodPost {
			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
			return
		}

		var req struct {
			Amount      string `json:"amount"`
			Currency    string `json:"currency"`
			Description string `json:"description"`
		}

		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			log.Printf("Error decoding request body: %v", err)
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}

		log.Printf("Payment request params: amount=%s currency=%s description=%s", req.Amount, req.Currency, req.Description)

		// Convert amount string to float64 for validation
		amount, err := strconv.ParseFloat(req.Amount, 64)
		if err != nil {
			log.Printf("Error parsing amount %q: %v", req.Amount, err)
			http.Error(w, "Invalid amount: "+err.Error(), http.StatusBadRequest)
			return
		}

		// Create payment token request
		tokenReq := &api2c2p.PaymentTokenRequest{
			MerchantID:          *merchantID,
			InvoiceNo:           fmt.Sprintf("INV%d", time.Now().Unix()),
			Description:         req.Description,
			AmountCents:         api2c2p.Cents(amount * 100),
			CurrencyCodeISO4217: req.Currency,
			PaymentChannel:      []api2c2p.PaymentTokenPaymentChannel{"QR"},
			//
			UserDefined1: "1",
			UserDefined2: "2",
			UserDefined3: "3",
			UserDefined4: "4",
			UserDefined5: "5",
			//
			// LoyaltyPoints: &api2c2p.LoyaltyPoints{
			// 	RedeemAmount: amount,
			// },
		}

		// Get payment token
		tokenResult, err := client.PaymentToken(r.Context(), tokenReq)
		if err != nil {
			log.Printf("Error getting payment token: %v", err)
			http.Error(w, "Error getting payment token: "+err.Error(), http.StatusInternalServerError)
			return
		}

		if tokenResult.PaymentToken == "" {
			log.Printf("Error getting payment token: %s", tokenResult.RespDesc)
			http.Error(w, "Error getting payment token: "+tokenResult.RespDesc, http.StatusInternalServerError)
			return
		}

		// Create QR payment
		qrResp, err := client.CreateQRPayment(r.Context(), &api2c2p.CreateQRPaymentParams{
			ClientIP:           client.GetIPAddress(r),
			PaymentToken:       tokenResult.PaymentToken,
			PaymentChannelCode: "PNQR",
			ResponseReturnUrl:  fmt.Sprintf("%s/qr-payment-callback", *serverURL),
		})
		if err != nil {
			log.Printf("Error creating QR payment: %v", err)
			http.Error(w, "Error creating QR payment: "+err.Error(), http.StatusInternalServerError)
			return
		}

		log.Printf("QR payment response: type=%s data=%s code=%s desc=%s timer=%s",
			qrResp.Type, qrResp.Data, qrResp.RespCode, qrResp.RespDesc, qrResp.ExpiryTimer)

		if qrResp.RespCode != "1005" { // Pending for user scan QR
			http.Error(w, fmt.Sprintf(`{"error":%q}`, qrResp.RespDesc), http.StatusBadRequest)
			return
		}

		// Return QR code URL in JSON response
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"paymentToken":      tokenResult.PaymentToken,
			"type":              qrResp.Type,
			"data":              qrResp.Data,
			"channelCode":       qrResp.ChannelCode,
			"expiryTimer":       qrResp.ExpiryTimer,
			"expiryDescription": qrResp.ExpiryDescription,
			"respCode":          qrResp.RespCode,
			"respDesc":          qrResp.RespDesc,
		})
	}
}

func handleQRPaymentCallback(w http.ResponseWriter, r *http.Request) {
	log.Printf("QR payment callback received: %+v", r.URL.Query())

	// Return success response
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"status": "success"})
}
